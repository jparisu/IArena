from __future__ import annotations

from typing import List
from dataclasses import dataclass

from IArena.interfaces.IPlayer import IPlayer
from IArena.arena.GenericGame import ClockGame
from IArena.grader.RulesGenerator import IRulesGenerator, RulesGeneratorSuite
from IArena.utils.YamlMixing import YamlMixing
from IArena.utils.printing import green_tick, red_cross



@dataclass(init=False)
class ReportCommonConfiguration(YamlMixing):
    """
    Common configurations of a report that are not related to the rules generation.
    This class is generated by a yaml dictionary.
    """

    move_timeout_s: float = 5
    total_timeout_s: float = 10
    max_score: float = float('inf')
    min_score: float = float('-inf')
    repetitions: int = 1
    fails_allowed: int = 0
    max_moves: int = 1000




@dataclass
class ReportResult:
    """
    Result for a report with its multiple configurations and repetitions.
    """

    successes: List[bool]
    messages: List[str]
    warnings: List[str]
    errors: List[str]

    def total(self) -> int:
        return len(self.successes)
    def passed(self) -> int:
        return sum(1 for s in self.successes if s)
    def failed(self) -> int:
        return sum(1 for s in self.successes if not s)


    def minimum_result(result1: ReportResult, result2: ReportResult) -> ReportResult:
        """
        Combine two ReportResults taking the minimum result for each field.
        """
        combined_successes = [s1 and s2 for s1, s2 in zip(result1.successes, result2.successes)]
        combined_messages = result1.messages + result2.messages
        combined_warnings = result1.warnings + result2.warnings
        combined_errors = result1.errors + result2.errors

        return ReportResult(
            successes=combined_successes,
            messages=combined_messages,
            warnings=combined_warnings,
            errors=combined_errors,
        )

    def __eq__(self, value):
        return self.successes == value.successes


class Report:
    """
    Class that represents a specific configuration or test for a given Game and Player.

    It contains common configurations and a suite of game configurations for the rules generator.
    It runs multiple games with different configurations and repetitions, and collects the results.
    """

    def __init__(
                self,
                rules_generator: IRulesGenerator,
                player: IPlayer,
                common_configuration: ReportCommonConfiguration,
                rules_suite: RulesGeneratorSuite,
            ):

        self._rules_generator = rules_generator
        self._player = player
        self._common_configuration = common_configuration
        self._rules_suite = rules_suite

        self._result = None
        self._inconsistency = False


    def run(
                self,
                debug: bool = False,
            ) -> ReportResult:

        if self._result is None:
            self._result = self._run(debug=debug)

        else:
            result = self._run(debug=debug)

            if result != self._result:
                self._inconsistency = True
            self._result = ReportResult.minimum_result(self._result, result)

        return self._result

    def _run(
                self,
                debug: bool = False,
            ) -> ReportResult:

        successes = []
        messages = []
        warnings = []
        errors = []

        for conf in self._rules_suite.get_configuration_iterator():

            rules = self._rules_generator.generate(conf)

            for i in range(self._common_configuration.repetitions):

                game = ClockGame(
                            rules,
                            [self._player],
                            move_timeout_s=self._common_configuration.move_timeout_s,
                            total_timeout_s=self._common_configuration.total_timeout_s,
                            max_moves=self._common_configuration.max_moves,
                        )

                correct_execution = True
                try:
                    score = game.play()[0]
                except Exception as e:
                    correct_execution = False
                    successes.append(False)
                    errors.append(f"Game crashed with conf {conf} repetition {i+1}: {{{e}}}")

                if correct_execution:
                    if score >= self._common_configuration.min_score:
                        successes.append(True)
                        if score > self._common_configuration.max_score:
                            warnings.append(f"Score {score} above max {self._common_configuration.max_score} with conf {conf} repetition {i+1}")

                    else:
                        successes.append(False)
                        if score < self._common_configuration.min_score:
                            messages.append(f"Score {score} below min {self._common_configuration.min_score} with conf {conf} repetition {i+1}")

                if debug:
                    if successes[-1]:
                        print(green_tick(), end="", flush=True)  # green small check
                    else:
                        print(red_cross(), end="", flush=True)  # red small cross


        _result = ReportResult(
                successes=successes,
                messages=messages,
                warnings=warnings,
                errors=errors,
            )

        return _result


    def get_result(self) -> ReportResult:
        if self._result is None:
            raise RuntimeError("Grader has not been run yet. Please run the grader before getting the result.")
        return self._result


    def calculate_grade(self) -> float:
        """
        Calculate grade according to:
        Max grade = 1
        Min grade = 0

        Each failure reduces the grade by 1 / (1+fails_allowed)

        Example:
        - If fails_allowed = 0, any failure results in a grade of 0.
        - If fails_allowed = 1, one failure results in a grade of 0.5, two or more failures result in a grade of 0.
        - If fails_allowed = 2, one failure results in a grade of 0.67, ...
        etc.
        """
        if self._result is None:
            raise RuntimeError("Grader has not been run yet. Please run the grader before calculating the final grade.")

        if self._result.total() == 0:
            return 0.0

        penalty_per_fail = 1.0 / (1 + self._common_configuration.fails_allowed)
        grade = 1.0 - (self._result.failed() * penalty_per_fail)
        if grade < 0.0:
            grade = 0.0
        return grade

    def has_inconsistency(self) -> bool:
        return self._inconsistency
