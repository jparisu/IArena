from typing import List
from dataclasses import dataclass

from IArena.interfaces.IPlayer import IPlayer
from IArena.arena.GenericGame import ClockGame
from IArena.grader.RulesGenerator import IRulesGenerator, RulesGeneratorSuite
from IArena.utils.YamlMixing import YamlMixing



@dataclass(init=False)
class ReportCommonConfiguration(YamlMixing):
    """
    Common configurations of a report that are not related to the rules generation.
    This class is generated by a yaml dictionary.
    """

    move_timeout_s: float = 5
    total_timeout_s: float = 10
    max_score: float = 1.0
    min_score: float = 0.0
    repetitions: int = 1
    fails_allowed: int = 0




@dataclass
class ReportResult:
    """
    Result for a report with its multiple configurations and repetitions.
    """

    successes: List[bool]
    messages: List[str]
    warnings: List[str]


class Report:
    """
    Class that represents a specific configuration or test for a given Game and Player.

    It contains common configurations and a suite of game configurations for the rules generator.
    It runs multiple games with different configurations and repetitions, and collects the results.
    """

    def __init__(
                self,
                rules_generator: IRulesGenerator,
                player: IPlayer,
                common_configuration: ReportCommonConfiguration,
                rules_suite: RulesGeneratorSuite,
            ):

        self._rules_generator = rules_generator
        self._player = player
        self._common_configuration = common_configuration
        self._rules_suite = rules_suite

        self._result = None


    def _reckon(
                self,
            ) -> ReportResult:

        successes = []
        messages = []
        warnings = []

        for conf in self._rules_suite.get_configuration_iterator():

            rules = self._rules_generator.generate(conf)

            game = ClockGame(
                        rules,
                        [self._player],
                        move_timeout_s=self._common_configuration.move_timeout_s,
                        total_timeout_s=self._common_configuration.total_timeout_s,
                    )

            score = game.play()[0]

            if score >= self._common_configuration.min_score:
                successes.append(True)
                if score > self._common_configuration.max_score:
                    warnings.append(f"Score {score} above max {self._common_configuration.max_score} with conf {conf}")

            else:
                successes.append(False)
                if score < self._common_configuration.max_score:
                    messages.append(f"Score {score} below max {self._common_configuration.max_score} with conf {conf}")


        self._result = ReportResult(
                successes=successes,
                messages=messages,
                warning=warnings,
            )

        return self._result


    def get_result(self) -> ReportResult:
        if self._result is None:
            self._reckon()
        return self._result


    def calculate_grade(self) -> float:
        """
        Calculate grade according to:
        Max grade = 1
        Min grade = 0

        Each failure reduces the grade by 1 / (1+fails_allowed)

        Example:
        - If fails_allowed = 0, any failure results in a grade of 0.
        - If fails_allowed = 1, one failure results in a grade of 0.5, two or more failures result in a grade of 0.
        - If fails_allowed = 2, one failure results in a grade of 0.67, ...
        etc.
        """
        if self._result is None:
            raise RuntimeError("Grader has not been run yet. Please run the grader before calculating the final grade.")

        if self._result.total == 0:
            return 0.0

        penalty_per_fail = 1.0 / (1 + self._common_configuration.fails_allowed)
        grade = 1.0 - (self._result.failed * penalty_per_fail)
        if grade < 0.0:
            grade = 0.0
        return grade
